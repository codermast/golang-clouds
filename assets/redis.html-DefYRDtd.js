import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,o as l}from"./app-Cjxa952C.js";const a={};function n(d,t){return l(),i("div",null,[...t[0]||(t[0]=[e(`<h1 id="redis-面试题" tabindex="-1"><a class="header-anchor" href="#redis-面试题"><span>Redis 面试题</span></a></h1><p>Redis 面试高频考点，覆盖数据结构、持久化、集群、缓存一致性、性能优化等核心知识。</p><hr><h2 id="一、数据结构" tabindex="-1"><a class="header-anchor" href="#一、数据结构"><span>一、数据结构</span></a></h2><h3 id="q1-redis-的五种基本数据类型及底层实现" tabindex="-1"><a class="header-anchor" href="#q1-redis-的五种基本数据类型及底层实现"><span>Q1: Redis 的五种基本数据类型及底层实现</span></a></h3><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">底层实现</th><th style="text-align:left;">应用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>String</strong></td><td style="text-align:left;">SDS（动态字符串）</td><td style="text-align:left;">缓存、计数器、分布式锁</td></tr><tr><td style="text-align:left;"><strong>Hash</strong></td><td style="text-align:left;">ziplist / hashtable</td><td style="text-align:left;">对象属性存储</td></tr><tr><td style="text-align:left;"><strong>List</strong></td><td style="text-align:left;">quicklist（ziplist + 链表）</td><td style="text-align:left;">消息队列、时间线</td></tr><tr><td style="text-align:left;"><strong>Set</strong></td><td style="text-align:left;">intset / hashtable</td><td style="text-align:left;">标签、共同好友</td></tr><tr><td style="text-align:left;"><strong>ZSet</strong></td><td style="text-align:left;">ziplist / skiplist + hashtable</td><td style="text-align:left;">排行榜、优先队列</td></tr></tbody></table><hr><h3 id="q2-为什么用-sds-而不是-c-字符串" tabindex="-1"><a class="header-anchor" href="#q2-为什么用-sds-而不是-c-字符串"><span>Q2: 为什么用 SDS 而不是 C 字符串？</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">C 字符串</th><th style="text-align:left;">SDS</th></tr></thead><tbody><tr><td style="text-align:left;">获取长度</td><td style="text-align:left;">O(N) 遍历</td><td style="text-align:left;">O(1) 直接读 len</td></tr><tr><td style="text-align:left;">缓冲区溢出</td><td style="text-align:left;">可能溢出</td><td style="text-align:left;">自动扩容</td></tr><tr><td style="text-align:left;">二进制安全</td><td style="text-align:left;">❌ 不支持 \\0</td><td style="text-align:left;">✅ 支持任意二进制</td></tr><tr><td style="text-align:left;">内存分配</td><td style="text-align:left;">每次修改都分配</td><td style="text-align:left;">空间预分配、惰性释放</td></tr></tbody></table><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sdshdr {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> len;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 已用长度</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> free;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 剩余空间</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> buf</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 实际数据</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="q3-zset-为什么用跳表而不是红黑树" tabindex="-1"><a class="header-anchor" href="#q3-zset-为什么用跳表而不是红黑树"><span>Q3: ZSet 为什么用跳表而不是红黑树？</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">跳表</th><th style="text-align:left;">红黑树</th></tr></thead><tbody><tr><td style="text-align:left;">实现复杂度</td><td style="text-align:left;">简单</td><td style="text-align:left;">复杂</td></tr><tr><td style="text-align:left;">范围查询</td><td style="text-align:left;">✅ O(logN + M)</td><td style="text-align:left;">需要中序遍历</td></tr><tr><td style="text-align:left;">内存占用</td><td style="text-align:left;">略多</td><td style="text-align:left;">略少</td></tr><tr><td style="text-align:left;">并发友好</td><td style="text-align:left;">更容易加锁</td><td style="text-align:left;">旋转操作复杂</td></tr></tbody></table><p><strong>结论：</strong> 跳表实现简单，范围查询效率高，更适合 Redis 场景。</p><hr><h3 id="q4-常用的扩展数据类型" tabindex="-1"><a class="header-anchor" href="#q4-常用的扩展数据类型"><span>Q4: 常用的扩展数据类型</span></a></h3><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th><th style="text-align:left;">应用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Bitmap</strong></td><td style="text-align:left;">位图</td><td style="text-align:left;">用户签到、在线状态</td></tr><tr><td style="text-align:left;"><strong>HyperLogLog</strong></td><td style="text-align:left;">基数统计（误差 0.81%）</td><td style="text-align:left;">UV 统计</td></tr><tr><td style="text-align:left;"><strong>Geo</strong></td><td style="text-align:left;">地理位置</td><td style="text-align:left;">附近的人、门店</td></tr><tr><td style="text-align:left;"><strong>Stream</strong></td><td style="text-align:left;">消息流</td><td style="text-align:left;">消息队列（Redis 5.0+）</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># Bitmap 签到</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SETBIT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:sign:1001:202401</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 1月2日签到</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">BITCOUNT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user:sign:1001:202401</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 统计签到天数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># HyperLogLog UV</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">PFADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> uv:20240101</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> user3</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">PFCOUNT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> uv:20240101</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="二、持久化" tabindex="-1"><a class="header-anchor" href="#二、持久化"><span>二、持久化</span></a></h2><h3 id="q5-rdb-和-aof-的区别" tabindex="-1"><a class="header-anchor" href="#q5-rdb-和-aof-的区别"><span>Q5: RDB 和 AOF 的区别</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">RDB</th><th style="text-align:left;">AOF</th></tr></thead><tbody><tr><td style="text-align:left;">原理</td><td style="text-align:left;">内存快照</td><td style="text-align:left;">命令日志</td></tr><tr><td style="text-align:left;">文件大小</td><td style="text-align:left;">小（二进制压缩）</td><td style="text-align:left;">大（文本命令）</td></tr><tr><td style="text-align:left;">恢复速度</td><td style="text-align:left;">快</td><td style="text-align:left;">慢</td></tr><tr><td style="text-align:left;">数据安全</td><td style="text-align:left;">可能丢失分钟级数据</td><td style="text-align:left;">最多丢 1 秒</td></tr><tr><td style="text-align:left;">性能影响</td><td style="text-align:left;">fork 子进程时影响</td><td style="text-align:left;">everysec 影响小</td></tr></tbody></table><p><strong>推荐：</strong> 同时开启 RDB + AOF，优先用 AOF 恢复。</p><hr><h3 id="q6-aof-的同步策略" tabindex="-1"><a class="header-anchor" href="#q6-aof-的同步策略"><span>Q6: AOF 的同步策略</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> always</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 每条命令都刷盘，最安全，性能最差</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> everysec</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 每秒刷盘（默认），折中方案</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> no</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 不主动刷盘，由 OS 决定，性能最好，风险最大</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>生产建议：</strong> 使用 <code>everysec</code>，最多丢失 1 秒数据。</p><hr><h3 id="q7-aof-重写机制" tabindex="-1"><a class="header-anchor" href="#q7-aof-重写机制"><span>Q7: AOF 重写机制</span></a></h3><p><strong>为什么需要重写？</strong></p><ul><li>AOF 文件持续增长</li><li>很多命令可以合并（如多次 INCR 合并为 SET）</li></ul><p><strong>重写流程：</strong></p><ol><li>fork 子进程，读取当前内存数据</li><li>子进程写入新 AOF 文件</li><li>主进程继续处理命令，增量写入 AOF 重写缓冲区</li><li>子进程完成后，将缓冲区内容追加到新文件</li><li>原子替换旧 AOF 文件</li></ol><hr><h3 id="q8-混合持久化" tabindex="-1"><a class="header-anchor" href="#q8-混合持久化"><span>Q8: 混合持久化</span></a></h3><p><strong>原理（Redis 4.0+）：</strong></p><ul><li>AOF 重写时，先写入 RDB 格式快照</li><li>快照后的增量命令以 AOF 格式追加</li></ul><p><strong>优点：</strong></p><ul><li>恢复速度快（RDB 部分）</li><li>数据安全性高（AOF 部分）</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">aof-use-rdb-preamble</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> yes</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 开启混合持久化</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="三、集群与高可用" tabindex="-1"><a class="header-anchor" href="#三、集群与高可用"><span>三、集群与高可用</span></a></h2><h3 id="q9-主从复制原理" tabindex="-1"><a class="header-anchor" href="#q9-主从复制原理"><span>Q9: 主从复制原理</span></a></h3><p><strong>全量复制：</strong></p><ol><li>Slave 发送 PSYNC 命令</li><li>Master 执行 BGSAVE，生成 RDB</li><li>Master 发送 RDB 给 Slave</li><li>Master 发送复制缓冲区内容</li></ol><p><strong>增量复制（Redis 2.8+）：</strong></p><ul><li>使用 <code>repl_backlog</code> 环形缓冲区</li><li>Slave 断线重连后，发送 offset</li><li>如果 offset 在 backlog 内，只同步增量</li></ul><hr><h3 id="q10-哨兵模式的选主流程" tabindex="-1"><a class="header-anchor" href="#q10-哨兵模式的选主流程"><span>Q10: 哨兵模式的选主流程</span></a></h3><p><strong>1. 主观下线（SDOWN）：</strong></p><ul><li>Sentinel 认为 Master 不可用</li></ul><p><strong>2. 客观下线（ODOWN）：</strong></p><ul><li>超过 quorum 个 Sentinel 都认为 Master 不可用</li></ul><p><strong>3. 选举 Sentinel Leader（Raft）</strong></p><p><strong>4. Sentinel Leader 选新 Master：</strong></p><ol><li>过滤不健康的 Slave</li><li>按优先级 <code>slave-priority</code> 排序</li><li>优先级相同，选复制偏移量最大的</li><li>偏移量相同，选 runid 最小的</li></ol><hr><h3 id="q11-cluster-模式的特点" tabindex="-1"><a class="header-anchor" href="#q11-cluster-模式的特点"><span>Q11: Cluster 模式的特点</span></a></h3><p><strong>槽位分配：</strong></p><ul><li>固定 16384 个槽位</li><li>数据按 <code>CRC16(key) % 16384</code> 分配到槽</li></ul><p><strong>多 key 操作限制：</strong></p><ul><li>多 key 命令（MGET、MSET）必须在同一槽</li><li>使用 hash tag：<code>{user}:1001</code> 和 <code>{user}:1002</code> 在同一槽</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># hash tag 用法</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {order}:1001</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value1</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {order}:1002</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> value2</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MGET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {order}:1001</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> {order}:1002</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # ✅ 可以</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="四、缓存问题" tabindex="-1"><a class="header-anchor" href="#四、缓存问题"><span>四、缓存问题</span></a></h2><h3 id="q12-缓存穿透、击穿、雪崩" tabindex="-1"><a class="header-anchor" href="#q12-缓存穿透、击穿、雪崩"><span>Q12: 缓存穿透、击穿、雪崩</span></a></h3><table><thead><tr><th style="text-align:left;">问题</th><th style="text-align:left;">原因</th><th style="text-align:left;">解决方案</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>穿透</strong></td><td style="text-align:left;">查询不存在的数据</td><td style="text-align:left;">布隆过滤器、缓存空值</td></tr><tr><td style="text-align:left;"><strong>击穿</strong></td><td style="text-align:left;">热点 key 过期</td><td style="text-align:left;">互斥锁、永不过期 + 异步更新</td></tr><tr><td style="text-align:left;"><strong>雪崩</strong></td><td style="text-align:left;">大量 key 同时过期</td><td style="text-align:left;">随机过期时间、多级缓存</td></tr></tbody></table><p><strong>缓存穿透 - 布隆过滤器：</strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 查询前先判断</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> not</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> bloom_filter.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">exists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> None</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 一定不存在</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">or</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> db.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>缓存击穿 - 互斥锁：</strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> get_data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data:</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;"> acquire_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key):</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 双重检查</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> not</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> db.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data, ttl)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        finally</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">            release_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="q13-缓存与数据库一致性" tabindex="-1"><a class="header-anchor" href="#q13-缓存与数据库一致性"><span>Q13: 缓存与数据库一致性</span></a></h3><p><strong>Cache Aside 模式（推荐）：</strong></p><p><strong>读流程：</strong></p><ol><li>先读缓存</li><li>缓存命中则返回</li><li>未命中则查 DB，写入缓存</li></ol><p><strong>写流程：</strong></p><ol><li>更新 DB</li><li>删除缓存（而非更新）</li></ol><p><strong>为什么删除而不是更新？</strong></p><ul><li>避免并发写导致缓存和 DB 不一致</li><li>延迟更新，下次读取时自动加载</li></ul><p><strong>延迟双删：</strong></p><div class="language-python line-numbers-mode" data-highlighter="shiki" data-ext="python" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-python"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">def</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> update_data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-light-font-style:inherit;--shiki-dark:#D19A66;--shiki-dark-font-style:italic;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">):</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 第一次删除</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    db.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, value)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    time.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)           </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 等待可能的并发读</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    cache.</span><span style="--shiki-light:#383A42;--shiki-dark:#61AFEF;">delete</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key)         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 第二次删除</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="q14-分布式锁的正确实现" tabindex="-1"><a class="header-anchor" href="#q14-分布式锁的正确实现"><span>Q14: 分布式锁的正确实现</span></a></h3><p><strong>加锁：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lock_key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> unique_value</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> NX</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> PX</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 30000</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># NX: 不存在才设置</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># PX: 30 秒过期</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解锁（Lua 保证原子性）：</strong></p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lua"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;get&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) == </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;del&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>锁续期（看门狗）：</strong></p><ul><li>后台线程定期检查锁</li><li>业务未完成则延长过期时间</li><li>Redisson 已内置实现</li></ul><hr><h2 id="五、性能优化" tabindex="-1"><a class="header-anchor" href="#五、性能优化"><span>五、性能优化</span></a></h2><h3 id="q15-内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#q15-内存淘汰策略"><span>Q15: 内存淘汰策略</span></a></h3><table><thead><tr><th style="text-align:left;">策略</th><th style="text-align:left;">说明</th><th style="text-align:left;">适用场景</th></tr></thead><tbody><tr><td style="text-align:left;">noeviction</td><td style="text-align:left;">不淘汰，写入报错</td><td style="text-align:left;">数据不能丢</td></tr><tr><td style="text-align:left;">allkeys-lru</td><td style="text-align:left;">淘汰最近最少使用</td><td style="text-align:left;">通用缓存</td></tr><tr><td style="text-align:left;">allkeys-lfu</td><td style="text-align:left;">淘汰最不常用（Redis 4.0+）</td><td style="text-align:left;">热点数据明显</td></tr><tr><td style="text-align:left;">volatile-ttl</td><td style="text-align:left;">淘汰快过期的</td><td style="text-align:left;">有过期时间的数据</td></tr><tr><td style="text-align:left;">volatile-lru</td><td style="text-align:left;">只在设置过期时间的 key 中淘汰</td><td style="text-align:left;">部分数据需持久化</td></tr></tbody></table><p><strong>推荐：</strong> <code>allkeys-lru</code> 或 <code>allkeys-lfu</code></p><hr><h3 id="q16-大-key-问题及处理" tabindex="-1"><a class="header-anchor" href="#q16-大-key-问题及处理"><span>Q16: 大 key 问题及处理</span></a></h3><p><strong>风险：</strong></p><ul><li>阻塞其他请求（单线程）</li><li>网络传输慢</li><li>DEL 可能阻塞主线程</li></ul><p><strong>发现大 key：</strong></p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --bigkeys</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --memkeys</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>处理方案：</strong></p><ol><li><strong>拆分</strong>：大 Hash 拆成多个小 Hash</li><li><strong>异步删除</strong>：<code>UNLINK</code> 代替 <code>DEL</code></li><li><strong>分批操作</strong>：<code>HSCAN/SSCAN</code> 分批读取</li></ol><hr><h3 id="q17-redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#q17-redis-为什么这么快"><span>Q17: Redis 为什么这么快</span></a></h3><table><thead><tr><th style="text-align:left;">因素</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>内存存储</strong></td><td style="text-align:left;">直接操作内存，无磁盘 IO</td></tr><tr><td style="text-align:left;"><strong>单线程命令处理</strong></td><td style="text-align:left;">无线程切换、无锁竞争</td></tr><tr><td style="text-align:left;"><strong>IO 多路复用</strong></td><td style="text-align:left;">epoll 高效处理并发连接</td></tr><tr><td style="text-align:left;"><strong>高效数据结构</strong></td><td style="text-align:left;">SDS、跳表、哈希表等</td></tr><tr><td style="text-align:left;"><strong>IO 多线程</strong>（Redis 6.0+）</td><td style="text-align:left;">读写网络 IO 多线程</td></tr></tbody></table><hr><h3 id="q18-pipeline-和事务的区别" tabindex="-1"><a class="header-anchor" href="#q18-pipeline-和事务的区别"><span>Q18: Pipeline 和事务的区别</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Pipeline</th><th style="text-align:left;">事务 (MULTI/EXEC)</th></tr></thead><tbody><tr><td style="text-align:left;">目的</td><td style="text-align:left;">减少网络往返</td><td style="text-align:left;">保证原子执行</td></tr><tr><td style="text-align:left;">原子性</td><td style="text-align:left;">❌</td><td style="text-align:left;">✅（部分原子）</td></tr><tr><td style="text-align:left;">回滚</td><td style="text-align:left;">-</td><td style="text-align:left;">❌ 不支持</td></tr><tr><td style="text-align:left;">性能</td><td style="text-align:left;">更好</td><td style="text-align:left;">略差</td></tr></tbody></table><p><strong>注意：</strong> Redis 事务不保证 ACID，编译错误会取消事务，运行时错误不回滚。</p><hr><h2 id="六、更多八股文" tabindex="-1"><a class="header-anchor" href="#六、更多八股文"><span>六、更多八股文</span></a></h2><h3 id="q19-过期删除策略" tabindex="-1"><a class="header-anchor" href="#q19-过期删除策略"><span>Q19: 过期删除策略</span></a></h3><table><thead><tr><th style="text-align:left;">策略</th><th style="text-align:left;">说明</th><th style="text-align:left;">使用场景</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>定时删除</strong></td><td style="text-align:left;">key 过期立即删除</td><td style="text-align:left;">CPU 开销大，不使用</td></tr><tr><td style="text-align:left;"><strong>惰性删除</strong></td><td style="text-align:left;">访问时检查是否过期</td><td style="text-align:left;">Redis 使用</td></tr><tr><td style="text-align:left;"><strong>定期删除</strong></td><td style="text-align:left;">周期性随机检查删除</td><td style="text-align:left;">Redis 使用</td></tr></tbody></table><p><strong>Redis 采用：</strong> 惰性删除 + 定期删除</p><hr><h3 id="q20-热点-key-问题" tabindex="-1"><a class="header-anchor" href="#q20-热点-key-问题"><span>Q20: 热点 Key 问题</span></a></h3><p><strong>危害：</strong></p><ul><li>单节点压力过大</li><li>网络带宽瓶颈</li></ul><p><strong>解决方案：</strong></p><table><thead><tr><th style="text-align:left;">方案</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">本地缓存</td><td style="text-align:left;">减少 Redis 访问</td></tr><tr><td style="text-align:left;">读写分离</td><td style="text-align:left;">多个从节点分担读压力</td></tr><tr><td style="text-align:left;">二级 key</td><td style="text-align:left;">将 key 拆分为多个</td></tr><tr><td style="text-align:left;">热点发现</td><td style="text-align:left;"><code>--hotkeys</code> 参数</td></tr></tbody></table><hr><h3 id="q21-redis-lua-脚本" tabindex="-1"><a class="header-anchor" href="#q21-redis-lua-脚本"><span>Q21: Redis Lua 脚本</span></a></h3><p><strong>优点：</strong></p><ul><li>原子性执行</li><li>减少网络往返</li><li>复杂逻辑封装</li></ul><p><strong>示例：</strong></p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lua"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 限流脚本</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> limit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;GET&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) or </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;0&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> + </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">limit</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;INCR&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;EXPIRE&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="q22-redlock-分布式锁" tabindex="-1"><a class="header-anchor" href="#q22-redlock-分布式锁"><span>Q22: Redlock 分布式锁</span></a></h3><p><strong>原理：</strong> 向多个独立 Redis 节点加锁</p><p><strong>步骤：</strong></p><ol><li>获取当前时间</li><li>依次向 N 个节点请求加锁</li><li>超过半数成功且耗时小于锁过期时间 → 加锁成功</li><li>失败则释放所有节点的锁</li></ol><p><strong>争议：</strong> Martin Kleppmann 质疑其正确性（时钟漂移问题）</p><hr><h3 id="q23-redis-集群扩容流程" tabindex="-1"><a class="header-anchor" href="#q23-redis-集群扩容流程"><span>Q23: Redis 集群扩容流程</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-bash"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 1. 添加新节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --cluster</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add-node</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> new_host:port</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> existing_host:port</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 2. 重新分配槽位</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --cluster</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> reshard</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> existing_host:port</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 3. 数据迁移（自动）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="q24-redis-和-memcached-的区别" tabindex="-1"><a class="header-anchor" href="#q24-redis-和-memcached-的区别"><span>Q24: Redis 和 Memcached 的区别</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">Redis</th><th style="text-align:left;">Memcached</th></tr></thead><tbody><tr><td style="text-align:left;">数据类型</td><td style="text-align:left;">丰富（5 种+）</td><td style="text-align:left;">只有 String</td></tr><tr><td style="text-align:left;">持久化</td><td style="text-align:left;">✅</td><td style="text-align:left;">❌</td></tr><tr><td style="text-align:left;">集群</td><td style="text-align:left;">✅ 原生支持</td><td style="text-align:left;">客户端分片</td></tr><tr><td style="text-align:left;">多线程</td><td style="text-align:left;">6.0+ IO 多线程</td><td style="text-align:left;">多线程</td></tr><tr><td style="text-align:left;">内存效率</td><td style="text-align:left;">略低</td><td style="text-align:left;">更高</td></tr></tbody></table><hr><h2 id="七、常用命令" tabindex="-1"><a class="header-anchor" href="#七、常用命令"><span>七、常用命令</span></a></h2><h3 id="q25-redis-各数据类型常用命令汇总" tabindex="-1"><a class="header-anchor" href="#q25-redis-各数据类型常用命令汇总"><span>Q25: Redis 各数据类型常用命令汇总</span></a></h3><table><thead><tr><th style="text-align:left;">分类</th><th style="text-align:left;">命令</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>String</strong></td><td style="text-align:left;"><code>SET</code> / <code>GET</code></td><td style="text-align:left;">设置/获取值</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>INCR</code> / <code>DECR</code></td><td style="text-align:left;">自增/自减</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SETNX</code></td><td style="text-align:left;">Key 不存在才设置（分布式锁核心）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SETEX</code></td><td style="text-align:left;">设置值并指定过期时间（秒）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>MSET</code> / <code>MGET</code></td><td style="text-align:left;">批量设置/获取</td></tr><tr><td style="text-align:left;"><strong>Hash</strong></td><td style="text-align:left;"><code>HSET</code> / <code>HGET</code></td><td style="text-align:left;">设置/获取字段</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>HMSET</code> / <code>HMGET</code></td><td style="text-align:left;">批量操作字段</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>HGETALL</code></td><td style="text-align:left;">获取所有字段和值</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>HDEL</code></td><td style="text-align:left;">删除字段</td></tr><tr><td style="text-align:left;"><strong>List</strong></td><td style="text-align:left;"><code>LPUSH</code> / <code>RPUSH</code></td><td style="text-align:left;">左推/右推入队列</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>LPOP</code> / <code>RPOP</code></td><td style="text-align:left;">左弹/右弹出队列</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>LRANGE</code></td><td style="text-align:left;">获取指定范围元素（如 0 -1）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>BLPOP</code> / <code>BRPOP</code></td><td style="text-align:left;">阻塞式弹出（消息队列常用）</td></tr><tr><td style="text-align:left;"><strong>Set</strong></td><td style="text-align:left;"><code>SADD</code> / <code>SREM</code></td><td style="text-align:left;">添加/删除元素</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SMEMBERS</code></td><td style="text-align:left;">获取所有元素</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SISMEMBER</code></td><td style="text-align:left;">判断元素是否存在</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SINTER</code> / <code>SUNION</code></td><td style="text-align:left;">交集 / 并集</td></tr><tr><td style="text-align:left;"><strong>ZSet</strong></td><td style="text-align:left;"><code>ZADD</code></td><td style="text-align:left;">添加元素（需指定 score）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>ZRANGE</code></td><td style="text-align:left;">按分数从小到大获取</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>ZREVRANGE</code></td><td style="text-align:left;">按分数从大到小获取</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>ZSCORE</code></td><td style="text-align:left;">获取元素分数</td></tr><tr><td style="text-align:left;"><strong>全局</strong></td><td style="text-align:left;"><code>DEL</code></td><td style="text-align:left;">删除 Key</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>EXPIRE</code> / <code>TTL</code></td><td style="text-align:left;">设置过期时间 / 查看剩余时间</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>EXISTS</code></td><td style="text-align:left;">判断 Key 是否存在</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>KEYS</code></td><td style="text-align:left;">查找所有符合模式的 Key（生产禁用）</td></tr><tr><td style="text-align:left;"></td><td style="text-align:left;"><code>SCAN</code></td><td style="text-align:left;">渐进式遍历 Key（推荐）</td></tr></tbody></table><hr><h3 id="q26-keys-和-scan-的区别" tabindex="-1"><a class="header-anchor" href="#q26-keys-和-scan-的区别"><span>Q26: KEYS 和 SCAN 的区别</span></a></h3><table><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">KEYS pattern</th><th style="text-align:left;">SCAN cursor</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>阻塞性</strong></td><td style="text-align:left;">✅ 阻塞主线程</td><td style="text-align:left;">❌ 非阻塞，分批进行</td></tr><tr><td style="text-align:left;"><strong>执行效率</strong></td><td style="text-align:left;">O(N) 一次性返回</td><td style="text-align:left;">O(1) 每次返回少量数据</td></tr><tr><td style="text-align:left;"><strong>生产环境</strong></td><td style="text-align:left;">⚠️ 禁止使用</td><td style="text-align:left;">✅ 推荐使用</td></tr><tr><td style="text-align:left;"><strong>数据一致性</strong></td><td style="text-align:left;">结果准确</td><td style="text-align:left;">可能会有重复或漏掉（期间有增删）</td></tr></tbody></table><hr><h2 id="八、高频考点清单" tabindex="-1"><a class="header-anchor" href="#八、高频考点清单"><span>八、高频考点清单</span></a></h2><h3 id="必考" tabindex="-1"><a class="header-anchor" href="#必考"><span>必考</span></a></h3><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 五种数据类型及底层实现</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 常见数据类型命令（SETNX, HGETALL, ZRANGE等）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> RDB vs AOF，同步策略</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 缓存穿透/击穿/雪崩解决方案</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 分布式锁正确实现</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 主从复制与哨兵选主流程</label></li></ul><h3 id="常考" tabindex="-1"><a class="header-anchor" href="#常考"><span>常考</span></a></h3><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> ZSet 为什么用跳表</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> AOF 重写与混合持久化</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> KEYS vs SCAN 的区别</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> Cluster 槽位与 hash tag</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 内存淘汰策略</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> 大 key 处理</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> 过期删除策略</label></li></ul><h3 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h3><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> Redis 单线程为何高性能</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> IO 多路复用原理</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> Raft 选举（Sentinel/Cluster）</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> 缓存与 DB 一致性方案</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-17" disabled="disabled"><label class="task-list-item-label" for="task-item-17"> Redlock 原理与争议</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-18" disabled="disabled"><label class="task-list-item-label" for="task-item-18"> 热点 Key 解决方案</label></li></ul>`,154)])])}const k=s(a,[["render",n]]),p=JSON.parse('{"path":"/interview/redis.html","title":"Redis 面试题","lang":"zh-CN","frontmatter":{"order":4,"icon":"logos:redis","description":"Redis 面试题 Redis 面试高频考点，覆盖数据结构、持久化、集群、缓存一致性、性能优化等核心知识。 一、数据结构 Q1: Redis 的五种基本数据类型及底层实现 Q2: 为什么用 SDS 而不是 C 字符串？ Q3: ZSet 为什么用跳表而不是红黑树？ 结论： 跳表实现简单，范围查询效率高，更适合 Redis 场景。 Q4: 常用的扩展数据...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-30T10:10:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.golangclouds.com/interview/redis.html"}],["meta",{"property":"og:site_name","content":"Golang 全栈指南"}],["meta",{"property":"og:title","content":"Redis 面试题"}],["meta",{"property":"og:description","content":"Redis 面试题 Redis 面试高频考点，覆盖数据结构、持久化、集群、缓存一致性、性能优化等核心知识。 一、数据结构 Q1: Redis 的五种基本数据类型及底层实现 Q2: 为什么用 SDS 而不是 C 字符串？ Q3: ZSet 为什么用跳表而不是红黑树？ 结论： 跳表实现简单，范围查询效率高，更适合 Redis 场景。 Q4: 常用的扩展数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-30T10:10:44.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-30T10:10:44.000Z"}]]},"git":{"createdTime":1765529054000,"updatedTime":1767089444000,"contributors":[{"name":"友人","username":"","email":"codermast@qq.com","commits":3}]},"readingTime":{"minutes":8.94,"words":2682},"filePathRelative":"interview/redis.md","autoDesc":true}');export{k as comp,p as data};
