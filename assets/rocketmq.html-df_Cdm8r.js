import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as l}from"./app-x2g52BM9.js";const s={};function c(o,e){return l(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="rocketmq-面试题" tabindex="-1"><a class="header-anchor" href="#rocketmq-面试题"><span>RocketMQ 面试题</span></a></h1><p>消息模型、顺序/延迟/事务消息、重试与堆积、存储与高可用。</p><h2 id="基础与模型" tabindex="-1"><a class="header-anchor" href="#基础与模型"><span>基础与模型</span></a></h2><ul><li>架构组件：Producer、Consumer、NameServer、Broker（CommitLog、ConsumeQueue、IndexFile）。</li><li>消息模型：主题 Topic、队列 Queue、Tag/Key；集群消费 vs 广播消费区别？</li><li>消息路由：NameServer 元数据、Producer 负载均衡策略（轮询/最小延迟等）。</li></ul><h2 id="可靠性与重试" tabindex="-1"><a class="header-anchor" href="#可靠性与重试"><span>可靠性与重试</span></a></h2><ul><li>至少一次/最多一次/恰好一次？RocketMQ 默认“至少一次”。</li><li>消费重试：<code>RECONSUME_LATER</code>，死信队列（DLQ）触发条件，最大重试次数配置？</li><li>发送重试：同步发送失败重试、异步回调重试；如何避免重复消费？（幂等/唯一键/去重表）。</li></ul><h2 id="顺序消息" tabindex="-1"><a class="header-anchor" href="#顺序消息"><span>顺序消息</span></a></h2><ul><li>全局顺序 vs 分区顺序；如何保证分区顺序？（同一业务键映射同一队列）。</li><li>消费端顺序保证：<code>MessageListenerOrderly</code>，消费超时/异常导致的队列锁转移。</li></ul><h2 id="延迟与定时" tabindex="-1"><a class="header-anchor" href="#延迟与定时"><span>延迟与定时</span></a></h2><ul><li>延迟等级（固定 18 级）机制；RocketMQ 5 支持任意时间延迟（定时消息），实现原理简述。</li></ul><h2 id="事务消息" tabindex="-1"><a class="header-anchor" href="#事务消息"><span>事务消息</span></a></h2><ul><li>事务消息流程：半消息（Prepare）→本地事务回查→Commit/Rollback。</li><li>回查触发条件？常见回查失败处理？</li><li>与本地事务一致性保证：本地事务要幂等、可查询。</li></ul><h2 id="存储与性能" tabindex="-1"><a class="header-anchor" href="#存储与性能"><span>存储与性能</span></a></h2><ul><li>CommitLog 追加写 + PageCache + 顺序刷盘（同步/异步）；为什么顺序写快？</li><li>ConsumeQueue/IndexFile 作用？</li><li>消息堆积处理：扩容消费实例、提高并发、批量拉取、升级机器；长时间堆积的风险（过期、落盘）。</li><li>写刷盘策略：同步刷盘（可靠） vs 异步刷盘（性能）。</li><li>高可用：主从同步复制、Dledger（RAFT）区别？同步/异步复制导致的数据一致性差异。</li></ul><h2 id="安全与限流" tabindex="-1"><a class="header-anchor" href="#安全与限流"><span>安全与限流</span></a></h2><ul><li>鉴权与 ACL 基本使用；限流/降级思路（速率限制、线程池隔离、拒绝策略）。</li></ul><h2 id="高频清单" tabindex="-1"><a class="header-anchor" href="#高频清单"><span>高频清单</span></a></h2><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 至少一次语义与幂等处理</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 消费重试与 DLQ 机制</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 顺序消息实现与队列选择</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 事务消息流程与回查条件</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> CommitLog/ConsumeQueue/IndexFile 作用</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 同步/异步刷盘与同步/异步复制区别</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 延迟消息实现与等级</label></li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 堆积处理策略</label></li></ul>',18)])])}const d=t(s,[["render",c]]),n=JSON.parse('{"path":"/interview/rocketmq.html","title":"RocketMQ 面试题","lang":"zh-CN","frontmatter":{"order":5,"icon":"simple-icons:apache","description":"RocketMQ 面试题 消息模型、顺序/延迟/事务消息、重试与堆积、存储与高可用。 基础与模型 架构组件：Producer、Consumer、NameServer、Broker（CommitLog、ConsumeQueue、IndexFile）。 消息模型：主题 Topic、队列 Queue、Tag/Key；集群消费 vs 广播消费区别？ 消息路由：...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 面试题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-12T08:44:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"友人\\",\\"url\\":\\"https://www.codermast.com\\",\\"email\\":\\"codermast@163.com\\"}]}"],["meta",{"property":"og:url","content":"https://www.codermast.com/interview/rocketmq.html"}],["meta",{"property":"og:site_name","content":"友人的编程指南"}],["meta",{"property":"og:title","content":"RocketMQ 面试题"}],["meta",{"property":"og:description","content":"RocketMQ 面试题 消息模型、顺序/延迟/事务消息、重试与堆积、存储与高可用。 基础与模型 架构组件：Producer、Consumer、NameServer、Broker（CommitLog、ConsumeQueue、IndexFile）。 消息模型：主题 Topic、队列 Queue、Tag/Key；集群消费 vs 广播消费区别？ 消息路由：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-12T08:44:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-12T08:44:14.000Z"}]]},"git":{"createdTime":1765529054000,"updatedTime":1765529054000,"contributors":[{"name":"友人","username":"","email":"codermast@qq.com","commits":1}]},"readingTime":{"minutes":1.84,"words":552},"filePathRelative":"interview/rocketmq.md","autoDesc":true}');export{d as comp,n as data};
